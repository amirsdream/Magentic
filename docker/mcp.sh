#!/usr/bin/env bash
#
# MCP Docker Management Script
# Manages MCP services with versioning, updates, and maintenance
#

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Version file
VERSION_FILE="$SCRIPT_DIR/.mcp-version"
COMPOSE_FILE="$SCRIPT_DIR/docker-compose.yml"
ENV_FILE="$SCRIPT_DIR/.env"
ENV_TEMPLATE="$SCRIPT_DIR/.env.template"

# Default version
DEFAULT_VERSION="1.0.0"

# ============================================
# Utility Functions
# ============================================

log_info() { echo -e "${BLUE}ℹ${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
log_error() { echo -e "${RED}✗${NC} $1"; }

get_current_version() {
    if [[ -f "$VERSION_FILE" ]]; then
        cat "$VERSION_FILE"
    else
        echo "$DEFAULT_VERSION"
    fi
}

set_version() {
    echo "$1" > "$VERSION_FILE"
    log_success "Version set to $1"
}

increment_version() {
    local version=$1
    local part=$2  # major, minor, patch
    
    IFS='.' read -r major minor patch <<< "$version"
    
    case $part in
        major)
            ((major++))
            minor=0
            patch=0
            ;;
        minor)
            ((minor++))
            patch=0
            ;;
        patch)
            ((patch++))
            ;;
    esac
    
    echo "$major.$minor.$patch"
}

# ============================================
# Docker Functions
# ============================================

check_docker() {
    if ! command -v docker &> /dev/null; then
        log_error "Docker is not installed"
        exit 1
    fi
    
    if ! docker info &> /dev/null; then
        log_error "Docker daemon is not running"
        exit 1
    fi
    
    if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
        log_error "Docker Compose is not installed"
        exit 1
    fi
}

get_compose_cmd() {
    if docker compose version &> /dev/null 2>&1; then
        echo "docker compose"
    else
        echo "docker-compose"
    fi
}

setup_env() {
    if [[ ! -f "$ENV_FILE" ]]; then
        if [[ -f "$ENV_TEMPLATE" ]]; then
            cp "$ENV_TEMPLATE" "$ENV_FILE"
            log_success "Created .env from template"
        else
            cat > "$ENV_FILE" << 'EOF'
# MCP Docker Configuration
# Generated by mcp.sh

# GitHub Token (optional, for increased API rate limits)
GITHUB_TOKEN=

# Gateway Configuration
LOG_LEVEL=INFO
HEALTH_CHECK_INTERVAL=60
REQUEST_TIMEOUT=30
MAX_RETRIES=3
ENABLE_METRICS=true

# Database Configuration
ALLOW_WRITE_OPS=true

# Python Execution Configuration
MAX_EXECUTION_TIME=30
MAX_MEMORY_MB=256

# Memory Store Configuration
DEFAULT_TTL=3600
MAX_KEYS_PER_NAMESPACE=10000
EOF
            log_success "Created default .env file"
        fi
    fi
}

create_workspace() {
    if [[ ! -d "$SCRIPT_DIR/shared-workspace" ]]; then
        mkdir -p "$SCRIPT_DIR/shared-workspace"
        log_success "Created shared-workspace directory"
    fi
    
    if [[ ! -d "$SCRIPT_DIR/data" ]]; then
        mkdir -p "$SCRIPT_DIR/data"
        log_success "Created data directory"
    fi
}

# ============================================
# Service Management
# ============================================

start_services() {
    local version=$(get_current_version)
    local compose_cmd=$(get_compose_cmd)
    
    log_info "Starting MCP services (v$version)..."
    
    check_docker
    setup_env
    create_workspace
    
    # Build and start
    $compose_cmd build
    $compose_cmd up -d
    
    log_info "Waiting for services to be healthy..."
    sleep 5
    
    # Check health
    local max_attempts=30
    local attempt=0
    
    while [[ $attempt -lt $max_attempts ]]; do
        if curl -sf http://localhost:9000/health > /dev/null 2>&1; then
            log_success "Gateway is healthy!"
            break
        fi
        ((attempt++))
        sleep 1
    done
    
    if [[ $attempt -eq $max_attempts ]]; then
        log_error "Gateway failed to start"
        $compose_cmd logs --tail=50 mcp-gateway
        exit 1
    fi
    
    show_status
}

stop_services() {
    local compose_cmd=$(get_compose_cmd)
    
    log_info "Stopping MCP services..."
    $compose_cmd down
    log_success "Services stopped"
}

restart_services() {
    stop_services
    start_services
}

show_status() {
    local compose_cmd=$(get_compose_cmd)
    local version=$(get_current_version)
    
    echo ""
    echo -e "${CYAN}╔════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║       MCP Docker Services (v$version)       ║${NC}"
    echo -e "${CYAN}╚════════════════════════════════════════════╝${NC}"
    echo ""
    
    # Show container status
    echo -e "${BLUE}Container Status:${NC}"
    $compose_cmd ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"
    
    echo ""
    
    # Try to get health info
    if curl -sf http://localhost:9000/health > /dev/null 2>&1; then
        echo -e "${BLUE}Service Health:${NC}"
        curl -s http://localhost:9000/health | python3 -m json.tool 2>/dev/null || curl -s http://localhost:9000/health
        
        echo ""
        echo -e "${BLUE}Available Tools:${NC}"
        curl -s http://localhost:9000/tools | python3 -c "
import sys, json
data = json.load(sys.stdin)
print(f\"Total: {data['total_tools']} tools\")
for server, count in data.get('by_server', {}).items():
    print(f\"  • {server}: {count} tools\")
" 2>/dev/null || echo "Unable to fetch tools"
    fi
    
    echo ""
    echo -e "${GREEN}Endpoints:${NC}"
    echo "  • Gateway:  http://localhost:9000"
    echo "  • API Docs: http://localhost:9000/docs"
    echo "  • Health:   http://localhost:9000/health"
    echo "  • Tools:    http://localhost:9000/tools"
    echo "  • Metrics:  http://localhost:9000/metrics"
    echo ""
}

show_logs() {
    local compose_cmd=$(get_compose_cmd)
    local service=${1:-}
    
    if [[ -n "$service" ]]; then
        $compose_cmd logs -f "$service"
    else
        $compose_cmd logs -f
    fi
}

# ============================================
# Version Management
# ============================================

update_version() {
    local current=$(get_current_version)
    local bump_type=${1:-patch}
    local new_version
    
    case $bump_type in
        major|minor|patch)
            new_version=$(increment_version "$current" "$bump_type")
            ;;
        *)
            # Assume it's a specific version
            new_version=$bump_type
            ;;
    esac
    
    log_info "Updating version: $current → $new_version"
    
    # Update version file
    set_version "$new_version"
    
    # Update docker-compose.yml with version labels
    if [[ -f "$COMPOSE_FILE" ]]; then
        # Update version in compose file (if using labels)
        local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        
        log_info "Rebuilding services with new version..."
        
        local compose_cmd=$(get_compose_cmd)
        
        # Rebuild with new version
        $compose_cmd build --build-arg VERSION="$new_version" --build-arg BUILD_DATE="$timestamp"
        
        log_success "Services rebuilt with version $new_version"
    fi
}

# ============================================
# Maintenance Functions
# ============================================

clean_all() {
    local compose_cmd=$(get_compose_cmd)
    
    log_warning "This will remove all containers, images, and volumes"
    read -p "Are you sure? (y/N) " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        $compose_cmd down -v --rmi all
        log_success "Cleaned all MCP resources"
    else
        log_info "Cancelled"
    fi
}

prune_images() {
    log_info "Pruning unused images..."
    docker image prune -f
    log_success "Pruned unused images"
}

backup_data() {
    local backup_dir="$SCRIPT_DIR/backups"
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local backup_file="$backup_dir/mcp_backup_$timestamp.tar.gz"
    
    mkdir -p "$backup_dir"
    
    log_info "Creating backup..."
    
    tar -czf "$backup_file" \
        -C "$SCRIPT_DIR" \
        shared-workspace \
        data \
        .env \
        .mcp-version \
        2>/dev/null || true
    
    log_success "Backup created: $backup_file"
}

# ============================================
# Testing Functions
# ============================================

run_tests() {
    log_info "Running MCP service tests..."
    
    local base_url="http://localhost:9000"
    local failed=0
    
    # Test 1: Health check
    echo -n "  Testing health endpoint... "
    if curl -sf "$base_url/health" > /dev/null; then
        echo -e "${GREEN}PASS${NC}"
    else
        echo -e "${RED}FAIL${NC}"
        ((failed++))
    fi
    
    # Test 2: Tools endpoint
    echo -n "  Testing tools endpoint... "
    if curl -sf "$base_url/tools" > /dev/null; then
        echo -e "${GREEN}PASS${NC}"
    else
        echo -e "${RED}FAIL${NC}"
        ((failed++))
    fi
    
    # Test 3: Servers endpoint
    echo -n "  Testing servers endpoint... "
    if curl -sf "$base_url/servers" > /dev/null; then
        echo -e "${GREEN}PASS${NC}"
    else
        echo -e "${RED}FAIL${NC}"
        ((failed++))
    fi
    
    # Test 4: Web search (if available)
    echo -n "  Testing websearch tool... "
    local search_result=$(curl -sf -X POST "$base_url/execute" \
        -H "Content-Type: application/json" \
        -d '{"server": "websearch", "tool": "search", "params": {"query": "test", "max_results": 1}}' 2>/dev/null)
    
    if [[ -n "$search_result" ]] && echo "$search_result" | grep -q '"success"'; then
        echo -e "${GREEN}PASS${NC}"
    else
        echo -e "${YELLOW}SKIP${NC} (service may not be available)"
    fi
    
    # Test 5: Memory store (if available)
    echo -n "  Testing memory store... "
    local mem_result=$(curl -sf -X POST "$base_url/execute" \
        -H "Content-Type: application/json" \
        -d '{"server": "memory", "tool": "set", "params": {"key": "test_key", "value": "test_value"}}' 2>/dev/null)
    
    if [[ -n "$mem_result" ]] && echo "$mem_result" | grep -q '"success"'; then
        echo -e "${GREEN}PASS${NC}"
    else
        echo -e "${YELLOW}SKIP${NC} (service may not be available)"
    fi
    
    echo ""
    if [[ $failed -eq 0 ]]; then
        log_success "All critical tests passed!"
    else
        log_error "$failed test(s) failed"
        exit 1
    fi
}

# ============================================
# Help
# ============================================

show_help() {
    local version=$(get_current_version)
    
    cat << EOF
${CYAN}MCP Docker Management Script v$version${NC}

${GREEN}Usage:${NC} $0 <command> [options]

${BLUE}Service Commands:${NC}
  start             Start all MCP services
  stop              Stop all MCP services  
  restart           Restart all MCP services
  status            Show service status and health
  logs [service]    Show logs (optionally for specific service)

${BLUE}Version Commands:${NC}
  version           Show current version
  bump <type>       Bump version (major|minor|patch) or set specific version
  
${BLUE}Maintenance Commands:${NC}
  test              Run service tests
  backup            Backup data and configuration
  clean             Remove all containers, images, and volumes
  prune             Remove unused Docker images

${BLUE}Examples:${NC}
  $0 start                    # Start services
  $0 bump patch               # Bump patch version (1.0.0 → 1.0.1)
  $0 bump minor               # Bump minor version (1.0.0 → 1.1.0)
  $0 bump 2.0.0               # Set specific version
  $0 logs mcp-gateway         # Show gateway logs
  $0 test                     # Run tests

${BLUE}Services:${NC}
  mcp-gateway       Central API gateway
  mcp-filesystem    File operations
  mcp-websearch     DuckDuckGo search
  mcp-github        GitHub API
  mcp-python        Python code execution
  mcp-database      SQLite database
  mcp-memory        Key-value store

EOF
}

# ============================================
# Main
# ============================================

main() {
    local command=${1:-help}
    shift || true
    
    case $command in
        start)
            start_services
            ;;
        stop)
            stop_services
            ;;
        restart)
            restart_services
            ;;
        status)
            show_status
            ;;
        logs)
            show_logs "$@"
            ;;
        version)
            echo "MCP Docker v$(get_current_version)"
            ;;
        bump|update)
            update_version "${1:-patch}"
            ;;
        test)
            run_tests
            ;;
        backup)
            backup_data
            ;;
        clean)
            clean_all
            ;;
        prune)
            prune_images
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

main "$@"
